name: Rolling Rebuilds

on:
  schedule:
    - cron: '0 2 * * 1/3'  # At 2:00am on Monday and Thursday
  workflow_dispatch:
    inputs:
      package_filter:
        description: 'Package name filter (regex)'
        type: string
        default: ''
      force:
        description: 'Force rebuild even if no changes detected'
        type: boolean
        default: false

concurrency:
  group: rolling-rebuilds
  cancel-in-progress: false

permissions:
  contents: write
  packages: write
  attestations: write
  id-token: write

jobs:
  find-rolling-packages:
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.find.outputs.packages }}
      has_packages: ${{ steps.find.outputs.has_packages }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Find rolling packages
        id: find
        run: |
          PACKAGES="[]"

          # Find recipes without top-level pkgver/version (these are rolling packages)
          for recipe in $(find binaries packages -name "*.yaml" 2>/dev/null); do
            # Skip disabled packages
            if grep -qE '^_disabled:\s*(true|yes)' "$recipe"; then
              continue
            fi

            # Check if package has a hardcoded version (pkgver or version at top level)
            if grep -qE '^(pkgver|version):' "$recipe"; then
              continue
            fi

            # Must have x_exec.pkgver to be useful
            if ! grep -qE '^[[:space:]]+pkgver:' "$recipe"; then
              continue
            fi

            pkg_family=$(echo "$recipe" | cut -d'/' -f2)
            recipe_name=$(basename "$recipe" .yaml)

            # Apply filter if provided
            if [ -n "${{ inputs.package_filter }}" ]; then
              if ! echo "$pkg_family" | grep -qE "${{ inputs.package_filter }}"; then
                continue
              fi
            fi

            PACKAGES=$(echo "$PACKAGES" | jq --arg path "$recipe" --arg family "$pkg_family" --arg name "$recipe_name" \
              '. + [{"path": $path, "family": $family, "name": $name}]')
          done

          PKG_COUNT=$(echo "$PACKAGES" | jq 'length')
          echo "::notice::Found ${PKG_COUNT} rolling packages"

          echo "packages=$(echo "$PACKAGES" | jq -c .)" >> $GITHUB_OUTPUT

          if [ "$PKG_COUNT" -gt 0 ]; then
            echo "has_packages=true" >> $GITHUB_OUTPUT
          else
            echo "has_packages=false" >> $GITHUB_OUTPUT
          fi

  check-for-updates:
    needs: find-rolling-packages
    if: needs.find-rolling-packages.outputs.has_packages == 'true'
    runs-on: ubuntu-latest
    outputs:
      to_rebuild: ${{ steps.check.outputs.to_rebuild }}
      has_updates: ${{ steps.check.outputs.has_updates }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Cache remote_pkgver state
        id: cache
        uses: actions/cache@v5
        with:
          path: .rolling-state.json
          key: rolling-remote-versions-v1
          restore-keys: |
            rolling-remote-versions-v1

      - name: Check for source updates
        id: check
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GHCR_OWNER: ${{ github.repository_owner }}
        run: |
          TO_REBUILD="[]"
          PACKAGES='${{ needs.find-rolling-packages.outputs.packages }}'
          STATE_FILE=".rolling-state.json"

          # Initialize state file if doesn't exist
          if [ ! -f "$STATE_FILE" ]; then
            echo "{}" > "$STATE_FILE"
          fi

          # Function to extract pkgver script from x_exec block
          extract_pkgver_script() {
            local file="$1"
            awk '
              /^x_exec:/ { in_xexec=1; next }
              in_xexec && /^[a-z_]+:/ && !/^[[:space:]]/ { in_xexec=0 }
              in_xexec && /^[[:space:]]+pkgver:[[:space:]]*\|/ { in_pkgver=1; next }
              in_pkgver && /^[[:space:]]+[a-z_]+:/ { in_pkgver=0 }
              in_pkgver { gsub(/^[[:space:]]{4}/, ""); print }
            ' "$file"
          }

          # Function to run pkgver script with timeout
          # Returns: second line (remote version), falls back to first line if only one output
          run_pkgver() {
            local script="$1"
            local output
            output=$(timeout 120s bash -c "$script" 2>/dev/null) || return 1

            # Try second line first (remote version)
            local version
            version=$(echo "$output" | sed -n '2p' | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | head -c 100)

            # Fall back to first line if second line is empty
            if [ -z "$version" ]; then
              version=$(echo "$output" | sed -n '1p' | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | head -c 100)
            fi

            echo "$version"
          }

          # Function to extract pkg name from recipe
          # Priority: first provides entry > pkg field
          get_pkg_name() {
            local file="$1"

            # Try to get first provides entry
            local provides_entry
            provides_entry=$(awk '
              /^provides:/ { in_provides=1; next }
              in_provides && /^[a-z_]+:/ && !/^[[:space:]]/ { exit }
              in_provides && /^[[:space:]]*-/ {
                gsub(/^[[:space:]]*-[[:space:]]*/, "")
                gsub(/^"/, ""); gsub(/"$/, "")
                # Extract base name before any separator (=>, ==, :)
                split($0, parts, /[=:>]/)
                print parts[1]
                exit
              }
            ' "$file")

            if [ -n "$provides_entry" ]; then
              echo "$provides_entry"
            else
              # Fallback to pkg field
              grep -E "^pkg:" "$file" | head -1 | sed 's/^pkg:[[:space:]]*//; s/^"//; s/"$//'
            fi
          }

          # Function to extract ghcr_pkg from recipe (custom GHCR path)
          get_ghcr_pkg() {
            local file="$1"
            grep -E "^ghcr_pkg:" "$file" | head -1 | sed 's/^ghcr_pkg:[[:space:]]*//; s/^"//; s/"$//'
          }

          echo "$PACKAGES" | jq -c '.[]' | while IFS= read -r pkg; do
            path=$(echo "$pkg" | jq -r '.path')
            family=$(echo "$pkg" | jq -r '.family')
            name=$(echo "$pkg" | jq -r '.name')

            # Extract pkg_name from recipe
            pkg_name=$(get_pkg_name "$path")
            if [ -z "$pkg_name" ]; then
              pkg_name="$family"  # fallback to family name
            fi

            # Check for ghcr_pkg
            ghcr_pkg=$(get_ghcr_pkg "$path")

            echo "::group::Checking $family/$name (pkg: $pkg_name)"

            # Skip if no ghcr_pkg
            if [ -z "$ghcr_pkg" ]; then
              echo "No ghcr_pkg set - cannot track version, skipping"
              echo "::endgroup::"
              continue
            fi

            NEEDS_REBUILD=false
            NEW_VERSION=""
            CACHED_VERSION=""

            # Get cached remote_pkgver from state file
            CACHED_VERSION=$(jq -r --arg key "$path" '.[$key] // ""' "$STATE_FILE")

            # Try to extract and run pkgver script
            PKGVER_SCRIPT=$(extract_pkgver_script "$path")

            if [ -n "$PKGVER_SCRIPT" ]; then
              echo "Found pkgver script, executing..."
              NEW_VERSION=$(run_pkgver "$PKGVER_SCRIPT")

              if [ -n "$NEW_VERSION" ]; then
                echo "New version from pkgver: $NEW_VERSION"
                echo "Cached version: ${CACHED_VERSION:-<none>}"

                # Compare new version with cached version
                if [ -n "$CACHED_VERSION" ] && [ "$NEW_VERSION" != "$CACHED_VERSION" ]; then
                  echo "Version changed: $CACHED_VERSION -> $NEW_VERSION"
                  NEEDS_REBUILD=true
                elif [ -z "$CACHED_VERSION" ]; then
                  echo "No cached version - first build or cache cleared, will trigger rebuild"
                  NEEDS_REBUILD=true
                else
                  echo "Version unchanged (matches cache)"
                fi
              else
                echo "pkgver script returned empty result"
              fi
            else
              echo "No pkgver script found, skipping version check"
            fi

            # Force rebuild if requested
            if [ "${{ inputs.force }}" == "true" ]; then
              NEEDS_REBUILD=true
            fi

            if [ "$NEEDS_REBUILD" == "true" ]; then
              echo "Marking for rebuild"
              # Write to temp file to persist across subshell
              echo "$path|$NEW_VERSION" >> /tmp/to_rebuild.txt
              # Update state file with new version
              jq --arg key "$path" --arg ver "$NEW_VERSION" '.[$key] = $ver' "$STATE_FILE" > "$STATE_FILE.tmp" && mv "$STATE_FILE.tmp" "$STATE_FILE"
            else
              echo "No rebuild needed"
            fi

            echo "::endgroup::"
          done

          # Build TO_REBUILD from temp file
          if [ -f /tmp/to_rebuild.txt ]; then
            while IFS='|' read -r path version; do
              TO_REBUILD=$(echo "$TO_REBUILD" | jq --arg path "$path" --arg version "$version" \
                '. + [{"path": $path, "new_version": $version}]')
            done < /tmp/to_rebuild.txt
          fi

          # Write final output
          REBUILD_COUNT=$(echo "$TO_REBUILD" | jq 'length')
          echo "::notice::${REBUILD_COUNT} packages need rebuilding"

          echo "to_rebuild=$(echo "$TO_REBUILD" | jq -c .)" >> $GITHUB_OUTPUT

          if [ "$REBUILD_COUNT" -gt 0 ]; then
            echo "has_updates=true" >> $GITHUB_OUTPUT
          else
            echo "has_updates=false" >> $GITHUB_OUTPUT
          fi

      - name: Update rolling state cache
        if: always()
        run: |
          if [ -f .rolling-state.json ]; then
            echo "State file updated with $(jq 'length' .rolling-state.json) tracked versions"
          fi

  rebuild:
    needs: [find-rolling-packages, check-for-updates]
    if: needs.check-for-updates.outputs.has_updates == 'true'
    strategy:
      fail-fast: false
      max-parallel: 2
      matrix:
        package: ${{ fromJson(needs.check-for-updates.outputs.to_rebuild) }}
    uses: ./.github/workflows/matrix_builds.yaml
    with:
      host: "ALL"
      sbuild-url: "https://raw.githubusercontent.com/${{ github.repository }}/${{ github.sha }}/${{ matrix.package.path }}"
      ghcr-url: ${{ format('ghcr.io/{0}', github.repository_owner) }}
      pkg-family: ${{ github.event.repository.name }}
      rebuild: true
      logs: true
    secrets: inherit

  update-cache:
    needs: [check-for-updates, rebuild]
    if: always() && needs.check-for-updates.outputs.has_updates == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Download tools
        run: |
          curl -fsSL "https://github.com/pkgforge/sbuilder/releases/download/latest/sbuild-cache-x86_64-linux" \
            -o /usr/local/bin/sbuild-cache && chmod +x /usr/local/bin/sbuild-cache || true
          curl -fsSL "https://github.com/pkgforge/sbuilder/releases/download/latest/sbuild-linter-x86_64-linux" \
            -o /usr/local/bin/sbuild-linter && chmod +x /usr/local/bin/sbuild-linter || true

      - name: Download existing cache
        continue-on-error: true
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh release download build-cache -p build_cache.sdb -D /tmp/ --repo "${{ github.repository }}" || \
            sbuild-cache --cache /tmp/build_cache.sdb init

      - name: Download build status artifacts
        uses: actions/download-artifact@v7
        with:
          pattern: build-status-*
          path: /tmp/build-statuses
          merge-multiple: true
        continue-on-error: true

      - name: Update cache with build results
        run: |
          PACKAGES='${{ needs.check-for-updates.outputs.to_rebuild }}'

          echo "$PACKAGES" | jq -c '.[]' | while read -r pkg; do
            path=$(echo "$pkg" | jq -r '.path')
            new_version=$(echo "$pkg" | jq -r '.new_version // "unknown"')

            # Extract package name from path
            pkg_name=$(basename "$(dirname "$path")")

            # Use version from pkgver output or fall back to recipe
            pkg_version="$new_version"
            if [ "$pkg_version" = "unknown" ] || [ -z "$pkg_version" ]; then
              if [ -f "$path" ]; then
                pkg_version=$(grep -E "^pkgver:" "$path" | head -1 | sed 's/pkgver:[[:space:]]*//; s/^["'"'"']//; s/["'"'"']$//' || echo "unknown")
              fi
            fi
            [ -z "$pkg_version" ] && pkg_version="unknown"

            # Compute recipe hash
            if [ -f "$path" ] && command -v sbuild-linter &>/dev/null; then
              recipe_hash=$(sbuild-linter hash --exclude-version "$path" 2>/dev/null || sha256sum "$path" | cut -d' ' -f1)
            else
              recipe_hash=$(sha256sum "$path" 2>/dev/null | cut -d' ' -f1 || echo "unknown")
            fi

            # Process build status for each host architecture
            for host in x86_64-linux aarch64-linux; do
              status="unknown"

              if [ -d "/tmp/build-statuses" ]; then
                for status_file in /tmp/build-statuses/build-status.json /tmp/build-statuses/*/build-status.json; do
                  [ -f "$status_file" ] || continue

                  recipe_url=$(jq -r '.recipe_url // ""' "$status_file" 2>/dev/null || echo "")
                  file_host=$(jq -r '.host // ""' "$status_file" 2>/dev/null || echo "")

                  if echo "$recipe_url" | grep -q "$path" && [ "$file_host" = "$host" ]; then
                    file_status=$(jq -r '.status // "unknown"' "$status_file" 2>/dev/null || echo "unknown")
                    case "$file_status" in
                      failure) status="failed" ;;
                      success) status="success" ;;
                      skipped) status="skipped" ;;
                      *) status="pending" ;;
                    esac
                    break
                  fi
                done
              fi

              # Skip if no status found for this host
              if [ "$status" = "unknown" ]; then
                continue
              fi

              echo "Package: $pkg_name ($host), Version: $pkg_version, Hash: ${recipe_hash:0:16}..., Status: $status"

              sbuild-cache --cache /tmp/build_cache.sdb update \
                --package "$pkg_name" \
                --host "$host" \
                --version "$pkg_version" \
                --hash "$recipe_hash" \
                --status "$status" || echo "Warning: Failed to update cache for $pkg_name ($host)"
            done
          done

      - name: Generate build summary
        run: |
          sbuild-cache --cache /tmp/build_cache.sdb gh-summary \
            --title "Rolling Rebuild Results" \
            --host x86_64-linux || true

      - name: Upload updated cache
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ -f "/tmp/build_cache.sdb" ]; then
            gh release upload build-cache /tmp/build_cache.sdb --clobber --repo "${{ github.repository }}" || {
              gh release create build-cache \
                --title "Build Cache" \
                --notes "Build cache for CI" \
                --prerelease \
                --repo "${{ github.repository }}" \
                /tmp/build_cache.sdb
            }
          fi

  summary:
    needs: [find-rolling-packages, check-for-updates, rebuild, update-cache]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Generate summary
        run: |
          echo "## ðŸ”„ Rolling Rebuild Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY

          FOUND=$(echo '${{ needs.find-rolling-packages.outputs.packages }}' | jq 'length')
          echo "| Rolling packages found | ${FOUND} |" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.check-for-updates.outputs.has_updates }}" == "true" ]; then
            REBUILT=$(echo '${{ needs.check-for-updates.outputs.to_rebuild }}' | jq 'length')
            echo "| Packages rebuilt | ${REBUILT} |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Packages rebuilt | 0 |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Build result:** ${{ needs.rebuild.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Cache update:** ${{ needs.update-cache.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
